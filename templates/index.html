<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Audio Chat (Ru/En)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .visualizer {
            width: 100%;
            height: 60px;
            background: #374151;
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .bar {
            width: 5px;
            background: #1a73e8;
            margin: 0 2px;
            height: 10px;
            transition: height 0.1s;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-900 to-gray-800 text-white min-h-screen">
    <div class="min-h-screen flex flex-col">
        <!-- Header -->
        <header class="bg-gray-800 shadow-lg">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex justify-between items-center py-4">
                    <h1 class="text-3xl font-bold text-white">üé§ AI Audio Chat</h1>
                    <select id="languageSelect" class="text-sm bg-gray-700 border border-gray-600 rounded text-white px-2 py-1">
                        <option value="en">English</option>
                        <option value="es">Spanish</option>
                        <option value="pt">Portuguese</option>
                        <option value="ru">Russian</option>
                        <option value="ja">Japanese</option>
                        <option value="de">German</option>
                        <option value="ko">Korean</option>
                        <option value="fr">French</option>
                    </select>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="flex-1 max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
            <!-- Chat Creator -->
            <div id="chatCreator" class="bg-gray-800 rounded-xl shadow-lg p-6 mb-8 max-w-md mx-auto">
                <h2 class="text-xl font-semibold text-white mb-4" data-key="createChat">Create New Chat</h2>
                <textarea id="promptInput" rows="3" class="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none" data-key="promptPlaceholder" placeholder="Describe person/situation, use female/male (e.g., 'old pirate male')"></textarea>
                <button id="createChatBtn" class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition duration-200" data-key="createBtn">Create Chat</button>
            </div>

            <!-- Filters -->
            <div class="bg-gray-800 rounded-xl shadow-lg p-4 mb-6 max-w-md mx-auto">
                <label class="block text-sm font-medium text-white mb-2">Filter by Voice:</label>
                <select id="filterSelect" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                    <option value="">All</option>
                    <option value="Zephyr">Zephyr</option>
                    <option value="Puck">Puck</option>
                    <option value="Umbriel">Umbriel</option>
                    <option value="Leda">Leda</option>
                    <option value="Enceladus">Enceladus</option>
                    <option value="Orus">Orus</option>
                    <option value="Aoede">Aoede</option>
                    <option value="Fenrir">Fenrir</option>
                    <option value="Kore">Kore</option>
                    <option value="Charon">Charon</option>
                    <option value="Erinome">Erinome</option>
                    <option value="Iapetus">Iapetus</option>
                </select>
            </div>

            <!-- Chat List -->
            <div id="chatList" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
                <!-- Cards will be added by JS -->
            </div>

            <!-- Chat Container -->
            <div class="bg-gray-800 rounded-xl shadow-lg p-8 max-w-2xl mx-auto" id="chatContainer" style="display: none;">
                <div class="text-center">
                    <img id="chatImage" class="w-48 h-48 object-cover rounded-full mx-auto mb-6 border-4 border-gray-200" style="display: none;" />
                    <div id="status" class="inline-block px-4 py-2 rounded-full text-sm font-medium mb-6 status disconnected">Disconnected</div>
                    <div class="flex justify-center space-x-4 mb-6">
                        <button id="startBtn" class="bg-green-500 hover:bg-green-600 text-white font-medium py-3 px-6 rounded-lg transition duration-200">üéôÔ∏è Start Chat</button>
                        <button id="endBtn" class="bg-red-500 hover:bg-red-600 text-white font-medium py-3 px-6 rounded-lg transition duration-200" disabled>‚èπÔ∏è End Chat</button>
                    </div>
                    <div class="visualizer" id="visualizer">
                        <!-- Bars will be added by JS -->
                    </div>
                    <div class="mt-8 text-center">
                        <p class="text-sm text-gray-400 mb-2">Support the project:</p>
                        <img src="/static/qr.png" alt="Donate USDT: TAMgnFiNycW9xx1zJHC6v1JWqpvhfoWwce" class="w-32 h-32 mx-auto" />
                        <p class="text-xs text-gray-500 mt-2">USDT: TAMgnFiNycW9xx1zJHC6v1JWqpvhfoWwce</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        (async () => {
        let currentChatId = null;
            let chatsData = {};
            let userLocation = null;

            // Declare UI elements early
            const languageSelect = document.getElementById('languageSelect');
            const chatList = document.getElementById('chatList');
            const createChatBtn = document.getElementById('createChatBtn');
            const promptInput = document.getElementById('promptInput');
            const startBtn = document.getElementById('startBtn');
            const endBtn = document.getElementById('endBtn');
            const statusDiv = document.getElementById('status');
            const visualizer = document.getElementById('visualizer');
            const filterSelect = document.getElementById('filterSelect');

            const translations = {
                en: {
                    title: "AI Audio Chat",
                    createChat: "Create New Chat",
                    promptPlaceholder: "Describe person/situation, use female/male (e.g., 'old pirate male')",
                    createBtn: "Create Chat",
                    filterLabel: "Filter by Voice",
                    startChat: "üéôÔ∏è Start Chat",
                    endChat: "‚èπÔ∏è End Chat",
                    disconnected: "Disconnected",
                    connected: "Connected",
                    connecting: "Connecting...",
                    error: "Error",
                    micDenied: "Mic Access Denied"
                },
                es: {
                    title: "Chat de Audio IA",
                    createChat: "Crear Nuevo Chat",
                    promptPlaceholder: "Describe persona/situaci√≥n, usa female/male (ej. 'viejo pirata male')",
                    createBtn: "Crear Chat",
                    filterLabel: "Filtrar por Voz",
                    startChat: "üéôÔ∏è Iniciar Chat",
                    endChat: "‚èπÔ∏è Terminar Chat",
                    disconnected: "Desconectado",
                    connected: "Conectado",
                    connecting: "Conectando...",
                    error: "Error",
                    micDenied: "Acceso al Micr√≥fono Denegado"
                },
                pt: {
                    title: "Chat de √Åudio IA",
                    createChat: "Criar Novo Chat",
                    promptPlaceholder: "Descreva pessoa/situa√ß√£o, use female/male (ex. 'velho pirata male')",
                    createBtn: "Criar Chat",
                    filterLabel: "Filtrar por Voz",
                    startChat: "üéôÔ∏è Iniciar Chat",
                    endChat: "‚èπÔ∏è Terminar Chat",
                    disconnected: "Desconectado",
                    connected: "Conectado",
                    connecting: "Conectando...",
                    error: "Erro",
                    micDenied: "Acesso ao Microfone Negado"
                },
                ru: {
                    title: "AI –ê—É–¥–∏–æ –ß–∞—Ç",
                    createChat: "–°–æ–∑–¥–∞—Ç—å –ù–æ–≤—ã–π –ß–∞—Ç",
                    promptPlaceholder: "–û–ø–∏—à–∏—Ç–µ —á–µ–ª–æ–≤–µ–∫–∞/—Å–∏—Ç—É–∞—Ü–∏—é, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ female/male (–ø—Ä–∏–º. '—Å—Ç–∞—Ä—ã–π –ø–∏—Ä–∞—Ç male')",
                    createBtn: "–°–æ–∑–¥–∞—Ç—å –ß–∞—Ç",
                    filterLabel: "–§–∏–ª—å—Ç—Ä –ø–æ –ì–æ–ª–æ—Å—É",
                    startChat: "üéôÔ∏è –ù–∞—á–∞—Ç—å –ß–∞—Ç",
                    endChat: "‚èπÔ∏è –ó–∞–≤–µ—Ä—à–∏—Ç—å –ß–∞—Ç",
                    disconnected: "–û—Ç–∫–ª—é—á–µ–Ω–æ",
                    connected: "–ü–æ–¥–∫–ª—é—á–µ–Ω–æ",
                    connecting: "–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...",
                    error: "–û—à–∏–±–∫–∞",
                    micDenied: "–î–æ—Å—Ç—É–ø –∫ –ú–∏–∫—Ä–æ—Ñ–æ–Ω—É –ó–∞–ø—Ä–µ—â–µ–Ω"
                },
                ja: {
                    title: "AI „Ç™„Éº„Éá„Ç£„Ç™„ÉÅ„É£„ÉÉ„Éà",
                    createChat: "Êñ∞„Åó„ÅÑ„ÉÅ„É£„ÉÉ„Éà„Çí‰ΩúÊàê",
                    promptPlaceholder: "‰∫∫/Áä∂Ê≥Å„ÇíË™¨Êòé„Åó„ÄÅfemale/male„Çí‰ΩøÁî® (‰æã 'old pirate male')",
                    createBtn: "„ÉÅ„É£„ÉÉ„Éà„Çí‰ΩúÊàê",
                    filterLabel: "Â£∞„Åß„Éï„Ç£„É´„Çø",
                    startChat: "üéôÔ∏è „ÉÅ„É£„ÉÉ„Éà„ÇíÈñãÂßã",
                    endChat: "‚èπÔ∏è „ÉÅ„É£„ÉÉ„Éà„ÇíÁµÇ‰∫Ü",
                    disconnected: "ÂàáÊñ≠",
                    connected: "Êé•Á∂ö",
                    connecting: "Êé•Á∂ö‰∏≠...",
                    error: "„Ç®„É©„Éº",
                    micDenied: "„Éû„Ç§„ÇØ„Ç¢„ÇØ„Çª„ÇπÊãíÂê¶"
                },
                de: {
                    title: "KI Audio Chat",
                    createChat: "Neuen Chat Erstellen",
                    promptPlaceholder: "Beschreibe Person/Situation, verwende female/male (z.B. 'alter Pirat male')",
                    createBtn: "Chat Erstellen",
                    filterLabel: "Nach Stimme Filtern",
                    startChat: "üéôÔ∏è Chat Starten",
                    endChat: "‚èπÔ∏è Chat Beenden",
                    disconnected: "Getrennt",
                    connected: "Verbunden",
                    connecting: "Verbinde...",
                    error: "Fehler",
                    micDenied: "Mikrofonzugriff Verweigert"
                },
                ko: {
                    title: "AI Ïò§ÎîîÏò§ Ï±ÑÌåÖ",
                    createChat: "ÏÉà Ï±ÑÌåÖ ÎßåÎì§Í∏∞",
                    promptPlaceholder: "ÏÇ¨Îûå/ÏÉÅÌô©ÏùÑ ÏÑ§Î™ÖÌïòÍ≥† female/male ÏÇ¨Ïö© (Ïòà 'old pirate male')",
                    createBtn: "Ï±ÑÌåÖ ÎßåÎì§Í∏∞",
                    filterLabel: "Î™©ÏÜåÎ¶¨Î°ú ÌïÑÌÑ∞",
                    startChat: "üéôÔ∏è Ï±ÑÌåÖ ÏãúÏûë",
                    endChat: "‚èπÔ∏è Ï±ÑÌåÖ Ï¢ÖÎ£å",
                    disconnected: "Ïó∞Í≤∞ ÎÅäÍπÄ",
                    connected: "Ïó∞Í≤∞Îê®",
                    connecting: "Ïó∞Í≤∞ Ï§ë...",
                    error: "Ïò§Î•ò",
                    micDenied: "ÎßàÏù¥ÌÅ¨ Ïï°ÏÑ∏Ïä§ Í±∞Î∂Ä"
                },
                fr: {
                    title: "Chat Audio IA",
                    createChat: "Cr√©er Nouveau Chat",
                    promptPlaceholder: "D√©crivez personne/situation, utilisez female/male (ex. 'vieux pirate male')",
                    createBtn: "Cr√©er Chat",
                    filterLabel: "Filtrer par Voix",
                    startChat: "üéôÔ∏è D√©marrer Chat",
                    endChat: "‚èπÔ∏è Terminer Chat",
                    disconnected: "D√©connect√©",
                    connected: "Connect√©",
                    connecting: "Connexion...",
                    error: "Erreur",
                    micDenied: "Acc√®s au Microphone Refus√©"
                }
            };

            const countryToLang = {
                RU: 'ru',
                ES: 'es',
                PT: 'pt',
                JP: 'ja',
                DE: 'de',
                KR: 'ko',
                FR: 'fr'
            };

            let currentLang = 'en';

            function updateInterfaceLanguage(lang) {
                currentLang = lang;
                const t = translations[lang] || translations.en;
                document.querySelector('h1').innerText = `üé§ ${t.title}`;
                document.querySelector('[data-key="createChat"]').innerText = t.createChat;
                promptInput.placeholder = t.promptPlaceholder;
                document.querySelector('[data-key="createBtn"]').innerText = t.createBtn;
                document.querySelector('label').innerText = t.filterLabel;
                startBtn.innerHTML = t.startChat;
                endBtn.innerHTML = t.endChat;
            }

            languageSelect.addEventListener('change', () => updateInterfaceLanguage(languageSelect.value));

            async function detectLanguageFromLocation(lat, lng) {
                try {
                    const response = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lng}&localityLanguage=en`);
                    const data = await response.json();
                    const countryCode = data.countryCode;
                    const detectedLang = countryToLang[countryCode] || 'en';
                    languageSelect.value = detectedLang;
                    updateInterfaceLanguage(detectedLang);
                } catch (e) {
                    console.error('Geocode error:', e);
                    updateInterfaceLanguage('en');
                }
            }

            // Get user geolocation
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        userLocation = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude
                        };
                        console.log('User location:', userLocation);
                        detectLanguageFromLocation(userLocation.lat, userLocation.lng);
                    },
                    (error) => {
                        console.error('Geolocation error:', error);
                        updateInterfaceLanguage('en');
                    }
                );
            } else {
                console.error('Geolocation not supported');
                updateInterfaceLanguage('en');
            }

            // Chat management
            const addedChatIds = new Set();

            // Initialize with default chat - but removed at user request

            async function loadChats() {
                try {
                    const response = await fetch('/chats');
                    chatsData = await response.json();
                    for (const [chatId, info] of Object.entries(chatsData)) {
                    if (chatId !== 'default') {
                        const title = `Chat ${chatList.children.length}`;
                        addCard(chatId, title, info.prompt, info.voice, info.image_url);
                    }
                    }
                } catch (e) {
                    console.error('Error loading chats:', e);
                }
            }

            function addCard(chatId, title, prompt, voice = 'Zephyr', image_url = '', likes = 0) {
                if (addedChatIds.has(chatId)) return;
                addedChatIds.add(chatId);
                const card = document.createElement('div');
                card.className = 'card bg-gray-800 rounded-xl shadow-lg overflow-hidden hover:shadow-xl transition-shadow duration-300 cursor-pointer relative group';
                card.dataset.chatId = chatId;
                const deleteBtn = chatId !== 'default' ? `<button class="absolute top-3 right-3 bg-red-500 hover:bg-red-600 text-white rounded-full w-8 h-8 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200 z-10">‚úï</button>` : '';
                const backgroundImage = image_url || 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" width="300" height="200" viewBox="0 0 300 200"><rect width="300" height="200" fill="#f3f4f6"/><circle cx="150" cy="80" r="30" fill="#d1d5db"/><path d="M130 110 Q150 130 170 110" stroke="#d1d5db" stroke-width="3" fill="none"/><text x="150" y="170" font-family="Arial" font-size="16" text-anchor="middle" fill="#6b7280">No Image</text></svg>');
                card.innerHTML = `
                    <div class="aspect-video relative">
                        <img src="${backgroundImage}" alt="Chat Image" class="w-full h-full object-cover" />
                        ${deleteBtn}
                    </div>
                    <div class="p-4">
                        <p class="text-gray-300 text-sm leading-relaxed">${prompt}</p>
                        <div class="mt-2 text-xs text-gray-400">${voice}</div>
                        <div class="flex items-center mt-2">
                            <button class="like-btn text-red-500 hover:text-red-600 mr-2">‚ù§Ô∏è</button>
                            <span class="likes-count text-sm text-gray-400">${likes}</span>
                        </div>
                    </div>
                `;
                card.addEventListener('click', () => startChatWith(chatId));
                const delBtn = card.querySelector('button');
                if (delBtn) {
                    delBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        deleteChat(chatId, card);
                    });
                }
                const likeBtn = card.querySelector('.like-btn');
                const likesCount = card.querySelector('.likes-count');
                likeBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    try {
                        const response = await fetch('/like_chat', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ chat_id: chatId })
                        });
                        const data = await response.json();
                        if (data.likes !== undefined) {
                            likesCount.textContent = data.likes;
                        } else if (data.error) {
                            alert(data.error);
                        }
                    } catch (err) {
                        console.error('Like error:', err);
                    }
                });
                chatList.appendChild(card);
            }

            async function deleteChat(chatId, card) {
                try {
                    const response = await fetch('/delete_chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chat_id: chatId })
                    });
                    if (response.ok) {
                        card.remove();
                        addedChatIds.delete(chatId);
                    }
                } catch (e) {
                    console.error('Error deleting chat:', e);
                }
            }

            // Load additional chats from server
            await loadChats();
            filterCards(); // Apply initial filter

            filterSelect.addEventListener('change', filterCards);

            function filterCards() {
                const selectedVoice = filterSelect.value;
                const cards = chatList.querySelectorAll('.card');
                cards.forEach(card => {
                    const voiceEl = card.querySelector('.text-xs');
                    const voice = voiceEl ? voiceEl.textContent : '';
                    card.style.display = (selectedVoice === '' || voice === selectedVoice) ? 'block' : 'none';
                });
            }

            async function translatePrompt(prompt, fromLang) {
                try {
                    const response = await fetch('/translate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text: prompt, from_lang: fromLang })
                    });
                    const data = await response.json();
                    return data.translated || prompt;
                } catch (e) {
                    console.error('Translation error:', e);
                    return prompt; // Fallback to original
                }
            }

            createChatBtn.onclick = async () => {
                const prompt = promptInput.value.trim();
                const selectedLang = languageSelect.value;
                if (prompt) {
                    createChatBtn.disabled = true;
                    promptInput.disabled = true;
                    createChatBtn.textContent = 'Creating...';
                    try {
                        let finalPrompt = await translatePrompt(prompt, selectedLang);
                        const response = await fetch('/create_chat', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ prompt: finalPrompt })
                        });
                        const { chat_id: chatId, voice, image_url } = await response.json();
                        addCard(chatId, `Chat ${chatList.children.length}`, finalPrompt, voice, image_url);
                        promptInput.value = '';
                    } catch (e) {
                        console.error('Error creating chat:', e);
                    } finally {
                        createChatBtn.disabled = false;
                        promptInput.disabled = false;
                        createChatBtn.textContent = 'Create Chat';
                    }
                }
            };

        function startChatWith(chatId) {
            currentChatId = chatId;
            const imgEl = document.getElementById('chatImage');
            if (chatsData[chatId] && chatsData[chatId].image_url) {
                imgEl.src = chatsData[chatId].image_url;
                imgEl.style.display = 'block';
            } else {
                imgEl.style.display = 'none';
            }
            document.getElementById('chatList').style.display = 'none';
            document.getElementById('chatCreator').style.display = 'none';
            document.getElementById('chatContainer').style.display = 'block';
            startChat();
        }

        // Setup visualizer bars
        const numBars = 20;
        const bars = [];
        for (let i = 0; i < numBars; i++) {
            const bar = document.createElement('div');
            bar.className = 'bar';
            visualizer.appendChild(bar);
            bars.push(bar);
        }

        let audioContext;
        let websocket;
        let stream;
        let processor;
        let isRecording = false;
        let nextStartTime = 0;

        // Constants matching server config
        const SEND_SAMPLE_RATE = 16000;
        const RECEIVE_SAMPLE_RATE = 24000;

        startBtn.onclick = startChat;
        endBtn.onclick = endChat;

        async function startChat() {
            try {
                startBtn.disabled = true;
                statusDiv.innerText = 'Connecting...';
                
                // Initialize WebSocket
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                websocket = new WebSocket(`${protocol}//${window.location.host}/ws`);

                websocket.onopen = () => {
                    // Send initialize message with chat_id
                    websocket.send(JSON.stringify({
                        type: "initialize",
                        chat_id: currentChatId
                    }));
                    statusDiv.innerText = 'Connected';
                    statusDiv.className = 'inline-block px-4 py-2 rounded-full text-sm font-medium mb-6 bg-green-100 text-green-800';
                    endBtn.disabled = false;
                    startAudio();
                };

                websocket.onmessage = handleMessage;

                websocket.onclose = () => {
                    statusDiv.innerText = 'Disconnected';
                    statusDiv.className = 'status disconnected';
                    stopAudio();
                    startBtn.disabled = false;
                    endBtn.disabled = true;
                };

                websocket.onerror = (error) => {
                    console.error('WebSocket Error:', error);
                    statusDiv.innerText = 'Error';
                };

            } catch (err) {
                console.error('Error starting chat:', err);
                statusDiv.innerText = 'Error starting chat';
                startBtn.disabled = false;
            }
        }

        async function startAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: SEND_SAMPLE_RATE,
                });
                
                // Get microphone access
                stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { 
                        channelCount: 1, 
                        sampleRate: SEND_SAMPLE_RATE 
                    } 
                });

                const source = audioContext.createMediaStreamSource(stream);
                
                // Use ScriptProcessor for raw PCM access (worklet would be better for production but this is simpler)
                processor = audioContext.createScriptProcessor(4096, 1, 1);
                
                source.connect(processor);
                processor.connect(audioContext.destination); // Mute loopback? No, needed for processing to run in some browsers
                // Wait, connecting to destination might cause feedback loop if not careful.
                // Usually we connect to destination to hear ourselves or to keep the processor alive.
                // To avoid hearing ourselves, we can connect to a GainNode with gain 0.
                const gain = audioContext.createGain();
                gain.gain.value = 0;
                processor.connect(gain);
                gain.connect(audioContext.destination);

                processor.onaudioprocess = (e) => {
                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                        const inputData = e.inputBuffer.getChannelData(0);
                        
                        // Convert Float32 to Int16 PCM
                        const pcmData = new Int16Array(inputData.length);
                        for (let i = 0; i < inputData.length; i++) {
                            // Clamp and scale
                            let s = Math.max(-1, Math.min(1, inputData[i]));
                            pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                        }

                        // Update visualizer (simple volume)
                        updateVisualizer(inputData);

                        // Send to server
                        const base64String = arrayBufferToBase64(pcmData.buffer);
                        websocket.send(JSON.stringify({
                            type: 'audio',
                            data: base64String
                        }));
                    }
                };
                
                isRecording = true;
                startBtn.classList.add('recording');

            } catch (err) {
                console.error('Error accessing microphone:', err);
                statusDiv.innerText = 'Mic Access Denied';
            }
        }

        function handleMessage(event) {
            const msg = JSON.parse(event.data);
            if (msg.type === 'audio') {
                playAudioChunk(msg.data);
            }
        }

        function playAudioChunk(base64Data) {
            if (!audioContext) return;

            // Decode base64 to Int16
            const raw = window.atob(base64Data);
            const rawLength = raw.length;
            const array = new Uint8Array(new ArrayBuffer(rawLength));
            for(let i = 0; i < rawLength; i++) {
                array[i] = raw.charCodeAt(i);
            }
            const pcm16 = new Int16Array(array.buffer);

            // Convert Int16 to Float32
            const float32 = new Float32Array(pcm16.length);
            for (let i = 0; i < pcm16.length; i++) {
                float32[i] = pcm16[i] / 32768;
            }

            // Create buffer
            const audioBuffer = audioContext.createBuffer(1, float32.length, RECEIVE_SAMPLE_RATE);
            audioBuffer.getChannelData(0).set(float32);

            // Schedule playback
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);

            // Basic scheduling to prevent overlap/gaps
            const currentTime = audioContext.currentTime;
            if (nextStartTime < currentTime) {
                nextStartTime = currentTime;
            }
            
            source.start(nextStartTime);
            nextStartTime += audioBuffer.duration;
        }

        function endChat() {
            if (websocket) {
                websocket.close();
            }
            stopAudio();
            startBtn.disabled = false;
            endBtn.disabled = true;
            statusDiv.innerText = 'Disconnected';
            statusDiv.className = 'status disconnected';
            startBtn.classList.remove('recording');
            // Back to chat list
            document.getElementById('chatContainer').style.display = 'none';
            document.getElementById('chatList').style.display = 'grid';
            document.getElementById('chatCreator').style.display = 'block';
        }

        function stopAudio() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            if (processor) {
                processor.disconnect();
            }
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close().catch(() => {});
            }
            isRecording = false;
        }

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        function updateVisualizer(data) {
            // Calculate a volume level manually since we have the data
            let sum = 0;
            for (let i = 0; i < data.length; i++) {
                sum += Math.abs(data[i]);
            }
            const volume = sum / data.length;

            // Randomly animate bars based on volume
            bars.forEach(bar => {
                const height = Math.min(100, Math.max(10, volume * 500 + Math.random() * 20));
                bar.style.height = height + '%';
            });
        }
        })();
    </script>
</body>
</html>
